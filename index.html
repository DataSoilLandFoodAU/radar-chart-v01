<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Polar Area Chart with Reserved Padding</title>
    <script src="https://cdn.jsdelivr.net/npm/chart.js@3"></script>
    <script src="https://cdn.jsdelivr.net/npm/csv/dist/csv.full.min.js"></script>
    <style>
        body {
            display: flex;
            justify-content: center;
            align-items: center;
            height: 100vh;
            margin: 0;
        }
    </style>
</head>

<body>
    <div>
        <canvas id="customPolarChart" width="600" height="600"></canvas>
    </div>

    <script>
            async function fetchZohoSheetData() {
        const accessToken = "1000.3aeeeebcbf94513339c3af0eed2508e4.2d32f4d412ad78056f2964f71d55e667"; // Update with latest token
        const sheetId = "hhsl7fba5a2332a0e41e08271b067e6b7e077";

        const url = `https://sheet.zohoapis.com.au/api/v2/spreadsheets/${sheetId}/data`;

        try {
            const response = await fetch(url, {
                method: "GET",
                headers: {
                    "Authorization": `Zoho-oauthtoken ${accessToken}`,
                    "Content-Type": "application/json"
                }
            });

            if (!response.ok) {
                throw new Error(`Error fetching data: ${response.statusText}`);
            }

            const jsonResponse = await response.json();
            console.log("Zoho Sheet Data:", jsonResponse);

            updateChartWithZohoData(jsonResponse);
        } catch (error) {
            console.error("Fetch error:", error);
        }
    }

    function updateChartWithZohoData(data) {
        const labels = [];
        const dataValues = [];

        data.data.forEach(row => {
            labels.push(row[0]);
            dataValues.push(Number(row[1]));
        });

        myChart.data.labels = labels;
        myChart.data.datasets[0].data = dataValues;
        myChart.update();
    }

    async function refreshZohoToken() {
        const clientId = "1000.XQ2BTW1QNWUN3P2BFIJ5S5RTJDPXPA";
        const clientSecret = "af480f4d8006344a4206a384ed7329152584fcfd90";
        const refreshToken = "1000.2d86c0430c05d3a3fbc20a9977c647fa.2d739999aed2b20e905f2b96261ed188";

        const url = "https://accounts.zoho.com.au/oauth/v2/token";

        const params = new URLSearchParams();
        params.append("refresh_token", refreshToken);
        params.append("client_id", clientId);
        params.append("client_secret", clientSecret);
        params.append("grant_type", "refresh_token");

        try {
            const response = await fetch(url, {
                method: "POST",
                headers: { "Content-Type": "application/x-www-form-urlencoded" },
                body: params
            });

            if (!response.ok) {
                throw new Error(`Token refresh failed: ${response.statusText}`);
            }

            const data = await response.json();
            console.log("New Access Token:", data.access_token);

            return data.access_token;
        } catch (error) {
            console.error("Token refresh error:", error);
        }
    }

    // Fetch data on page load
    fetchZohoSheetData();
    
function hexToRgba(hex, alpha) {
  const r = parseInt(hex.slice(1, 3), 16);
  const g = parseInt(hex.slice(3, 5), 16);
  const b = parseInt(hex.slice(5, 7), 16);
  return `rgba(${r}, ${g}, ${b}, ${alpha})`;
}

        // Data values and labels
        const dataValues = [3, 1, 2, 4, 3, 1, 2];
        const labels = ["Groundcover","Infiltration", "Aggregate Stability 1", "Aggregate Stability 2", "Soil pH", "Topsoil Depth", "Organism Diversity"];

        // Assign colors based on data values (red to green scale)
        const segmentColors = dataValues.map(value => {
            if (value === 1) return "#bf4526"; // Red
            if (value === 2) return "#e6d419"; // Yellow
            if (value === 3) return "#98d613"; // Light Yellowish Green
            if (value === 4) return "#10a30d"; // Green
            return "#CCCCCC"; // Default (if value is out of range)
        });

        // Category-based colors for outer rings
        const categoryColors = {
            A: "#668fd1", // Blue for Category A
            B: "#ab79d4", // Pink for Category B
            C: "#79d4a6"  // Green for Category C
        };

        // Mapping each label to its category
        const categoryMapping = ["A", "A","A","A", "B", "C", "C"];

        // Create the chart
        const ctx = document.getElementById("customPolarChart").getContext("2d");

        const arcTextPlugin = {
  id: 'arcText',
  afterDraw(chart) {
    const { ctx, scales, data } = chart;
    const { r } = scales;

    if (!r) return;

    ctx.save();

    const labels = data.labels;
    const centerX = r.xCenter;
    const centerY = r.yCenter;
    const outerRadius = r.drawingArea + 30; // Position labels slightly outside the chart

    const angleOffset = 27 * (Math.PI / 180); // 36 degrees in radians

    ctx.font = 'bold 14px Arial';
    ctx.fillStyle = '#000';

    labels.forEach((label, index) => {
      const baseAngle = r.getIndexAngle(index) - Math.PI / 2; // Adjust for -90 degrees
      const angle = baseAngle + angleOffset;

      const labelRadius = outerRadius;

      // Break the label into individual characters for arc rendering
      const characters = label.split('');
      const totalArcLength = characters.length * 8; // Approximate arc length per character
      const startAngle = angle - totalArcLength / (2 * labelRadius); // Center the label along the arc

      let currentAngle = startAngle;

      characters.forEach((char) => {
        const x = centerX + Math.cos(currentAngle) * labelRadius;
        const y = centerY + Math.sin(currentAngle) * labelRadius;

        // Rotate the canvas to align each character with the arc
        ctx.save();
        ctx.translate(x, y);
        ctx.rotate(currentAngle + Math.PI / 2);
        ctx.textAlign = 'center';
        ctx.textBaseline = 'middle';
        ctx.fillText(char, 0, 0);
        ctx.restore();

        // Advance to the next character's position
        currentAngle += 8 / labelRadius; // Adjust arc spacing
      });
    });

    ctx.restore();
  },
};

    // Register the custom plugin
    Chart.register(arcTextPlugin);

        new Chart(ctx, {
            type: "polarArea",
            data: {
                labels: labels,
                datasets: [{
                    data: dataValues,
                    backgroundColor: segmentColors, // Set segment colors
                }]
            },
            options: {
                responsive: true,
                layout: {
                    padding: {
                        left: 100,  // Reserve 100px on the left
                        right: 100, // Reserve 100px on the right
                        top: 100,   // Reserve 100px on the top
                        bottom: 100 // Reserve 100px on the bottom
                    }
                },
                scales: {
                    r: {
                        beginAtZero: true, // Ensure scale starts from 0
                        min: 0,
                        max: 4, // Set max to 4 to match data values
                        ticks: {
                            stepSize: 1,
                            display: false
                        }
                    }
                },
                plugins: {
                    legend: {
                        display: false // legend
                    },
                    customLabels: {}
                },
                elements: {
                    arc: {
                        borderWidth: 0 // default segment borders
                    }
                }
            },
            plugins: [
                {
                    id: "outerBorder",
                    beforeDraw(chart) {
                        const { ctx, chartArea, scales } = chart;
                        const { r } = scales;

                        // Correct center coordinates of the chart area
                        const centerX = chartArea.left + (chartArea.right - chartArea.left) / 2;
                        const centerY = chartArea.top + (chartArea.bottom - chartArea.top) / 2;

                        // Adjust outer radius for padding
                        const outerRadius = r.drawingArea + 30;

                        // Draw the outer category borders
                        chart.data.labels.forEach((label, index) => {
                            const category = categoryMapping[index];
                            const color = categoryColors[category];

                            // Calculate start and end angles for each segment
                            const startAngle = r.getIndexAngle(index) - Math.PI / 2; // Adjust angle (-90 degrees)
                            const endAngle = r.getIndexAngle(index + 1) - Math.PI / 2; // Adjust angle (-90 degrees)

                            // Draw the arc for the outer ring
                            ctx.save();
                            ctx.beginPath();
                            ctx.arc(centerX, centerY, outerRadius, startAngle, endAngle);
                            ctx.lineWidth = 60; // Thickness of outer ring
                            ctx.strokeStyle = hexToRgba(color, 0.5); // Category color
                            ctx.stroke();
                            ctx.restore();
                        });
                    }
                },
                {
                    id: "gridInFront",
                    afterDraw(chart) {
                        const { ctx, scales } = chart;

                        // Ensure radial scale exists
                        const r = scales.r;
                        if (!r) {
                            console.error("Radial scale (scales.r) is missing!");
                            return;
                        }

                        ctx.save();

                        try {
                            // Safely access angleLines properties
                            const angleLineColor = (r.angleLines && r.angleLines.color) || "#DDD";
                            const angleLineWidth = (r.angleLines && r.angleLines.lineWidth) || 1;

                            // Safely access grid properties
                            const gridColor = (r.grid && r.grid.color) || "#DDD";
                            const gridLineWidth = (r.grid && r.grid.lineWidth) || 1;

                            // Draw concentric grid lines
                            r.ticks.forEach((tick, index) => {
                                const radius = r.getDistanceFromCenterForValue(tick.value);

                                if (radius) {
                                    ctx.beginPath();
                                    ctx.arc(r.xCenter, r.yCenter, radius, 0, Math.PI * 2);
                                    ctx.strokeStyle = gridColor;
                                    ctx.lineWidth = gridLineWidth;
                                    ctx.stroke();
                                }
                            });

                            // Draw radial category lines
                            r._pointLabels.forEach((label, index) => {
                                const angle = r.getIndexAngle(index) - Math.PI / 2;
                                const x = r.xCenter + Math.cos(angle) * r.drawingArea;
                                const y = r.yCenter + Math.sin(angle) * r.drawingArea;

                                ctx.beginPath();
                                ctx.moveTo(r.xCenter, r.yCenter);
                                ctx.lineTo(x, y);
                                ctx.strokeStyle = angleLineColor;
                                ctx.lineWidth = angleLineWidth;
                                ctx.stroke();
                            });
                        } catch (error) {
                            console.error("Error in custom plugin:", error);
                        }

                        ctx.restore();
                    }
                }
            ]
        });
    </script>
</body>

</html>