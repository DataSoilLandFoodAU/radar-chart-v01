<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Polar Area Chart with Reserved Padding</title>
    <script src="https://cdn.jsdelivr.net/npm/chart.js@3"></script>
    <script src="https://cdn.jsdelivr.net/npm/csv/dist/csv.full.min.js"></script>
    <style>
        body {
            display: flex;
            justify-content: center;
            align-items: center;
            height: 100vh;
            margin: 0;
        }
    </style>
</head>

<body>
    <div>
        <canvas id="customPolarChart" width="600" height="600"></canvas>
    </div>

    <script>
        const accessToken = "1000.7c58f14a79e0eaaa6978754b65512740.a3f021a8cad177050edddb340ebc08b5";  // Replace with your actual token
        const spreadsheetId = "hhsl7fba5a2332a0e41e08271b067e6b7e077"; // Replace with your Zoho Sheet ID
        const worksheetName = "Input"; // The worksheet name you want to access

        async function fetchZohoSheetData() {
            const url = `https://sheet.zoho.com/api/v2/${spreadsheetId}`;

            // âœ… Request Parameters (Correct Format)
            const params = new URLSearchParams({
                method: "worksheet.records.fetch",
                worksheet_name: worksheetName,
                header_row: 1,
                render_option: "formatted",
                records_start_index: 1
            });

            try {
                const response = await fetch(url, {
                    method: "POST",
                    headers: {
                        "Authorization": `Zoho-oauthtoken ${accessToken}`,
                        "Content-Type": "application/x-www-form-urlencoded"
                    },
                    body: params
                });

                if (!response.ok) {
                    throw new Error(`HTTP Error ${response.status}: ${await response.text()}`);
                }

                const data = await response.json();
                console.log("ðŸ“Œ Zoho Sheet Data:", data);

                document.getElementById("output").textContent = JSON.stringify(data.records, null, 2);

                return data.records; // Return fetched data

            } catch (error) {
                console.error("âŒ Error Fetching Data:", error);
                document.getElementById("output").textContent = `Error: ${error.message}`;
                return null;
            }
        }

        async function generateChart() {
            const dataRecords = await fetchZohoSheetData();
            if (!dataRecords) return;

            // Extract values from API response
            const labelsAPI = dataRecords.map(record => record.Column1 || "Unknown");
            const dataValuesAPI = dataRecords.map(record => parseInt(record.Column2) || 0);

        function hexToRgba(hex, alpha) {
            const r = parseInt(hex.slice(1, 3), 16);
            const g = parseInt(hex.slice(3, 5), 16);
            const b = parseInt(hex.slice(5, 7), 16);
            return `rgba(${r}, ${g}, ${b}, ${alpha})`;
        }

        // Data values and labels
        const dataValues = [3, 1, 2, 4, 3, 1, 2];
        const labels = ["Groundcover", "Infiltration", "Aggregate Stability 1", "Aggregate Stability 2", "Soil pH", "Topsoil Depth", "Organism Diversity"];

        // Assign colors based on data values (red to green scale)
        const segmentColors = dataValues.map(value => {
            if (value === 1) return "#bf4526"; // Red
            if (value === 2) return "#e6d419"; // Yellow
            if (value === 3) return "#98d613"; // Light Yellowish Green
            if (value === 4) return "#10a30d"; // Green
            return "#CCCCCC"; // Default (if value is out of range)
        });

        // Category-based colors for outer rings
        const categoryColors = {
            A: "#668fd1", // Blue for Category A
            B: "#ab79d4", // Pink for Category B
            C: "#79d4a6"  // Green for Category C
        };

        // Mapping each label to its category
        const categoryMapping = ["A", "A", "A", "A", "B", "C", "C"];

        // Create the chart
        const ctx = document.getElementById("customPolarChart").getContext("2d");

        const arcTextPlugin = {
            id: 'arcText',
            afterDraw(chart) {
                const { ctx, scales, data } = chart;
                const { r } = scales;

                if (!r) return;

                ctx.save();

                const labels = data.labels;
                const centerX = r.xCenter;
                const centerY = r.yCenter;
                const outerRadius = r.drawingArea + 30; // Position labels slightly outside the chart

                const angleOffset = 27 * (Math.PI / 180); // 36 degrees in radians

                ctx.font = 'bold 14px Arial';
                ctx.fillStyle = '#000';

                labels.forEach((label, index) => {
                    const baseAngle = r.getIndexAngle(index) - Math.PI / 2; // Adjust for -90 degrees
                    const angle = baseAngle + angleOffset;

                    const labelRadius = outerRadius;

                    // Break the label into individual characters for arc rendering
                    const characters = label.split('');
                    const totalArcLength = characters.length * 8; // Approximate arc length per character
                    const startAngle = angle - totalArcLength / (2 * labelRadius); // Center the label along the arc

                    let currentAngle = startAngle;

                    characters.forEach((char) => {
                        const x = centerX + Math.cos(currentAngle) * labelRadius;
                        const y = centerY + Math.sin(currentAngle) * labelRadius;

                        // Rotate the canvas to align each character with the arc
                        ctx.save();
                        ctx.translate(x, y);
                        ctx.rotate(currentAngle + Math.PI / 2);
                        ctx.textAlign = 'center';
                        ctx.textBaseline = 'middle';
                        ctx.fillText(char, 0, 0);
                        ctx.restore();

                        // Advance to the next character's position
                        currentAngle += 8 / labelRadius; // Adjust arc spacing
                    });
                });

                ctx.restore();
            },
        };

        // Register the custom plugin
        Chart.register(arcTextPlugin);

        new Chart(ctx, {
            type: "polarArea",
            data: {
                labels: labels,
                datasets: [{
                    data: dataValues,
                    backgroundColor: segmentColors, // Set segment colors
                }]
            },
            options: {
                responsive: true,
                layout: {
                    padding: {
                        left: 100,  // Reserve 100px on the left
                        right: 100, // Reserve 100px on the right
                        top: 100,   // Reserve 100px on the top
                        bottom: 100 // Reserve 100px on the bottom
                    }
                },
                scales: {
                    r: {
                        beginAtZero: true, // Ensure scale starts from 0
                        min: 0,
                        max: 4, // Set max to 4 to match data values
                        ticks: {
                            stepSize: 1,
                            display: false
                        }
                    }
                },
                plugins: {
                    legend: {
                        display: false // legend
                    },
                    customLabels: {}
                },
                elements: {
                    arc: {
                        borderWidth: 0 // default segment borders
                    }
                }
            },
            plugins: [
                {
                    id: "outerBorder",
                    beforeDraw(chart) {
                        const { ctx, chartArea, scales } = chart;
                        const { r } = scales;

                        // Correct center coordinates of the chart area
                        const centerX = chartArea.left + (chartArea.right - chartArea.left) / 2;
                        const centerY = chartArea.top + (chartArea.bottom - chartArea.top) / 2;

                        // Adjust outer radius for padding
                        const outerRadius = r.drawingArea + 30;

                        // Draw the outer category borders
                        chart.data.labels.forEach((label, index) => {
                            const category = categoryMapping[index];
                            const color = categoryColors[category];

                            // Calculate start and end angles for each segment
                            const startAngle = r.getIndexAngle(index) - Math.PI / 2; // Adjust angle (-90 degrees)
                            const endAngle = r.getIndexAngle(index + 1) - Math.PI / 2; // Adjust angle (-90 degrees)

                            // Draw the arc for the outer ring
                            ctx.save();
                            ctx.beginPath();
                            ctx.arc(centerX, centerY, outerRadius, startAngle, endAngle);
                            ctx.lineWidth = 60; // Thickness of outer ring
                            ctx.strokeStyle = hexToRgba(color, 0.5); // Category color
                            ctx.stroke();
                            ctx.restore();
                        });
                    }
                },
                {
                    id: "gridInFront",
                    afterDraw(chart) {
                        const { ctx, scales } = chart;

                        // Ensure radial scale exists
                        const r = scales.r;
                        if (!r) {
                            console.error("Radial scale (scales.r) is missing!");
                            return;
                        }

                        ctx.save();

                        try {
                            // Safely access angleLines properties
                            const angleLineColor = (r.angleLines && r.angleLines.color) || "#DDD";
                            const angleLineWidth = (r.angleLines && r.angleLines.lineWidth) || 1;

                            // Safely access grid properties
                            const gridColor = (r.grid && r.grid.color) || "#DDD";
                            const gridLineWidth = (r.grid && r.grid.lineWidth) || 1;

                            // Draw concentric grid lines
                            r.ticks.forEach((tick, index) => {
                                const radius = r.getDistanceFromCenterForValue(tick.value);

                                if (radius) {
                                    ctx.beginPath();
                                    ctx.arc(r.xCenter, r.yCenter, radius, 0, Math.PI * 2);
                                    ctx.strokeStyle = gridColor;
                                    ctx.lineWidth = gridLineWidth;
                                    ctx.stroke();
                                }
                            });

                            // Draw radial category lines
                            r._pointLabels.forEach((label, index) => {
                                const angle = r.getIndexAngle(index) - Math.PI / 2;
                                const x = r.xCenter + Math.cos(angle) * r.drawingArea;
                                const y = r.yCenter + Math.sin(angle) * r.drawingArea;

                                ctx.beginPath();
                                ctx.moveTo(r.xCenter, r.yCenter);
                                ctx.lineTo(x, y);
                                ctx.strokeStyle = angleLineColor;
                                ctx.lineWidth = angleLineWidth;
                                ctx.stroke();
                            });
                        } catch (error) {
                            console.error("Error in custom plugin:", error);
                        }

                        ctx.restore();
                    }
                }
            ]
        });
    }
    window.onload = generateChart;
    </script>
</body>

</html>